---
layout: single
title:  "Java 객체지향 프로그래밍 #7"
---
### 추상클래스(abstract class)
```java
abstract class Player{
  Player(){}
  abstract void play(int pos); // 추상메서드
  abstract void stop(); // 추상메서드
}
class CDPlayer extends Player{
  void play(int currentPos){
    // 조상 추상메서드를 구현
  }
  void stop(){
    // 조상 추상메서드를 구현
  }
  
  // CDPlayer 클래스에 추가로 정의된 멤버
  int currentTrack;
  void nextTrack(){
    // 구현 내용
  }
}
```
오버라이딩과 추상메서드를 선언하는 차이는, abstract를 붙여서 추상메서드를 선언하는 이유는   
자손클래스에서 추상메서드를 반드시 구현하도록 강요하기 위해서이다.  
추상클래스를 조상으로 둔 자손클래스는 반드시 추상메서드를 구현해야한다.

### 인터페이스(interface)
인터페이스는 일종의 추상클래스이지만,  
인터페이스는 수현된 것은 아무 것도 없고 밑그림만 그려져 있는 '기본 설계도'라 할 수 있다.  
오직 추상메서드와 상수만을 멤버로 가질 수 있다.

```java
interface 인터페이스 이름 {
  public static final 타입 상수이름 = 값;
  public abstract 메서드이름(매개변수목록);
}
```
일반적인 클래스의 멤버들과 달리 인터페이스의 멤버들은 제약사항이 있다.  
- 모든 멤버변수는 public static final 이어야 하며, 이를 생략할 수 있다.
- 모든 메서드는 public abstract 이어야 하며, 이를 생략할 수 있다.
컴파일러가 자동으로 추가해준다.  

#### 인터페이스의 상속
인터페이스는 인터페이스로부터만 상속받을 수 있고, 클래스와는 달리 다중상속이 가능하다.

**오버라이딩 할 때는 조상의 메서드보다 넓은 범위의 접근 제어자를 지정해야한다.**  
**인터페이스의 모든 메서드에는 public abstract가 붙어있다는 것을 기억하자.**

#### 인터페이스를 이용한 다형성
다형성: 자손클래스의 인스턴스를 조상타입의 참조변수로 참조하는 것이 가능하다.  
**리턴타입이 인터페이스라는 것은 메서드가 해당 인터페이스를 구현한 클래스의 인스턴스를 반환한다는 것을 의미한다.**  

#### 인터페이스의 장점
- 개발시간을 단축시킬 수 있다.
- 표준화가 가능하다.
- 서로 관계없는 클래스들에게 관계를 맺어 줄 수 있다.
- 독립적인 프로그래밍이 가능하다.

### 내부 클래스(inner class)
내부 클래스의 장점
- 내부 클래스에서 외부 클래스의 멤버들을 쉽게 접근할 수 있다.
- 코드의 복잡성을 줄일 수 있다.(캡슐화) 
<img width="463" alt="inner-class-image-01" src="https://user-images.githubusercontent.com/97990285/151864295-d693d9af-851d-4622-800a-9f84f71fc3c4.png">

#### 익명 클래스(anonymous class)
클래스의 선언과 객체의 생성을 동시에 하기 때문에 단 한번만 사용될 수 있고,  
오직 하나의 객체만을 생성할 수 있는 일회용 클래스이다.
```java
new 조상클래스이름(){
  // 멤버 선언
}
new 구현인터페이스이름(){
  // 멤버 선언
}
```
